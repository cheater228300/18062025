### 12. Битовые операторы. Логические побитовые операции и операции сдвига. Средства выравнивания. Примеры.
#### Теория
**Битовые операторы** позволяют работать с отдельными битами целочисленных переменных.
**Логические побитовые операции**:
- `&` (побитовое И): Устанавливает бит в 1, если он равен 1 в обоих операндах.
- `|` (побитовое ИЛИ): Устанавливает бит в 1, если он равен 1 хотя бы в одном операнде.
- `^` (побитовое исключающее ИЛИ): Устанавливает бит в 1, если он равен 1 только в одном операнде.
- `~` (побитовое НЕ): Инвертирует все биты.
**Операции сдвига**:
- `<<` (сдвиг влево): Сдвигает биты влево, добавляя нули справа.
- `>>` (сдвиг вправо): Сдвигает биты вправо, заполняя старшие биты нулём (для беззнаковых чисел) или знаковым битом (для знаковых).
**Средства выравнивания**:
- Выравнивание памяти используется для размещения данных на адресах, кратных определённому числу (например, 4 или 8 байт).
- В Си выравнивание структур контролируется компилятором, но можно использовать директивы, такие как `#pragma pack` или атрибуты `__attribute__((aligned(n)))` (в GCC).
- Выравнивание улучшает производительность, но может увеличивать размер структур.
операции сдвига. Средства выравнивание. 
1. Логические побитовые операции
Побитовое И (&)
Возвращает 1, если оба соответствующих бита равны 1
Пример: 0b1100 & 0b1010 = 0b1000 (12 & 10 = 8)
Применение: маскирование битов, сброс отдельных битов
Побитовое ИЛИ (|)
Возвращает 1, если хотя бы один из битов равен 1
Пример: 0b1100 | 0b1010 = 0b1110 (12 | 10 = 14)
Применение: установка битов
Побитовое исключающее ИЛИ (^)
Возвращает 1, если биты разные
Пример: 0b1100 ^ 0b1010 = 0b0110 (12 ^ 10 = 6)
Свойство: a ^ a = 0, a ^ 0 = a
Применение: переключение битов, шифрование
Побитовое НЕ (~)
Инвертирует все биты числа
Пример: ~0b0011 = 0b1100 (для 4-битного числа, ~3 = 12)
Важно: результат зависит от размера типа
2. Операции сдвига
Логический сдвиг влево (<<)
Сдвигает биты влево, справа добавляются нули
Эквивалентно умножению на 2^n
Пример: 0b0001 << 2 = 0b0100 (1 << 2 = 4)
Особенности:
При переполнении старшие биты теряются
Для отрицательных чисел результат зависит от реализации
Арифметический сдвиг вправо (>>)
Для беззнаковых чисел: добавляет нули слева
Для знаковых чисел: обычно сохраняет знаковый бит (реализационно-зависимо)
Эквивалентно делению на 2^n (с округлением вниз)
Примеры:
0b1000 >> 2 = 0b0010 (8 >> 2 = 2)
0b11110000 >> 2 = 0b11111100 (знаковый сдвиг для -16)
3. Выравнивание данных
Принципы выравнивания
Данные в памяти располагаются по адресам, кратным их размеру
Например, 4-байтный int выравнивается по адресам, кратным 4
Цель: оптимизация доступа к памяти процессором
// Включение выравнивания (по умолчанию)
struct Aligned {
  char a;   // 1 байт
  int b;   // 4 байта (выравнивание по 4)
}; // Размер = 8 байт (1 + 3 padding + 4)
// Отключение выравнивания (GCC)
struct __attribute__((packed)) Packed {
  char a;
  int b;
}; // Размер = 5 байт
// Указание выравнивания (C11)
_Alignas(8) int x; // Выравнивание по 8 байт





